# artmidi.py - articulation and MIDI

from microbit import *
from micropython import kbd_intr

octaveidx=0
OCTAVES = [3*12,4*12,5*12]

#TODO: move string selection and capo to fret:bit
stringidx = 0
STRINGNAMES = "EADGB"
OPENSTRINGS = [4,9,2,7,11] # C+semitones
rootidx = OPENSTRINGS[stringidx]

#TODO: how do we get rootidx when on fretbit?
#don't need to, we will have a much higher range of bitmasks
#with just one set, so it will already have been factored in.
def getsemi(si): #0,1,2...
    return OCTAVES[octaveidx] + rootidx + si

# Auto-generated by chords.py (semitone offsets)
CHORDS = (
(0,), (0, 7), (0, 3, 7), (0, 4, 7),
(0, 4, 7, 10), (0, 4, 8), (0, 3, 7, 10), (0, 4, 7, 11),
(0, 5, 7), (0, 7, 14), (0, 3, 7, 10, 14), (0, 4, 7, 10, 14),
(0, 5, 7, 10), (0, 3, 6, 9), (0, 4, 7, 9), (0,)
)

DPINS = (pin8,pin12,pin13,pin14,pin15,pin16)
PINS = (pin1,pin8,pin12,pin2,pin13,pin14,pin15,pin16)

MASKS = (1,2,4,8,16,32,64,128)
PLUCK=1<<5
LOW=1<<4
MID=1<<3
HIGH=1<<2

def init():
    kbd_intr(-1)
    for p in PINS:
        if p in DPINS:
            p.set_pull(pin0.NO_PULL)
        else:
            p.is_touched()

def scan():
    r = 0
    for i in range(len(PINS)):
        p = PINS[i]
        if p in DPINS:
            v = p.read_digital() == 0
        else:
            v = p.is_touched()
        if v:
            r += 1<<i
    return r

def rdfret():
    if not uart.any(): return None
    #TODO: read into prepared bytearray(1) to prevent garbage collection
    #TODO: read sequences of any number of bytes
    #read, if high bit set, this is byte 0, if clear, this is 'next byte'.
    #read just 1 byte here, cooperatively schedule and just overlay
    #on a prepared bytearray of the max size we want to support at this end.
    #this saves us blocking here if not enough bytes arrived yet.
    b = uart.read(1)
    return b[0]

class MIDI():
    NOTE_ON = 0x90
    NOTE_OFF = 0x80

    @staticmethod
    def send(b0, b1, b2=None):
        #TODO: prevent garbage collection due to object trashing
        if b2 is None:
            #TODO: write into prepared bytearray(2) and set m as reference
            m = bytes([b0, b1])
        else:
            #TODO: write into prepared bytearray(3) and set m as reference
            m = bytes([b0, b1, b2])
        uart.write(m)

    def __init__(self, c=0, v=0x7F):
        self.c = c
        self.v = v

    def notes_on(self, notes, velocity=None):
        #TODO: add support for byte/buffer protocol for reusable bytearray
        if velocity is None: velocity = self.v
        if type(notes) not in (list, tuple):
            self.send(self.NOTE_ON | self.c, notes, velocity)
        else:
            for n in notes:
                self.send(self.NOTE_ON | self.c, n, velocity)

    def notes_off(self, notes, velocity=0x7F):
        #TODO: add support for byte/buffer protocol for reusable bytearray
        if velocity is None: velocity = self.v
        if type(notes) not in (list, tuple):
            self.send(self.NOTE_OFF | self.c, notes, velocity)
        else:
            for n in notes:
                self.send(self.NOTE_OFF | self.c, n, velocity)

def highest_bit(mask):
    b = -1
    while mask != 0:
        mask >>= 1
        b += 1
    return b

def lowest_bit(mask):
    if mask == 0: return -1
    b = 0
    while mask & 0x01 != 0x01:
        mask >>= 1
        b += 1
    return b


midi = MIDI()
playing = None
plucked = False

def send(tm, am, chords=False):
    global playing, plucked

    if not chords: #single note
        if tm == 0:
            notes = getsemi(0) # open string
        else:
            pad = 1 + highest_bit(tm)
            notes = getsemi(pad)

    else: #chord
        if tm == 0:
            #TODO: recycle rather than garbage collect
            notes = [] # silence
        else:
            pad = 1 + lowest_bit(tm)
            #TODO: recycle rather than garbage collect
            # next 4 pad positions from chord root are binary index of chord
            notes = [getsemi(x+pad) for x in CHORDS[(tm>>pad) & 0x0F]]

    pluck = (am & PLUCK) != 0
    if pluck and not plucked: #Â just plucked
        if playing is not None:
            midi.notes_off(playing)
        midi.notes_on(notes)
        playing = notes

    if playing is not None:
        if notes is None or notes != playing:
            midi.notes_off(playing)
            playing = None

    plucked = pluck

def play():
    global octaveidx, stringidx, rootidx
    pam = 0
    ptm = 0
    chords = False
    display.show(STRINGNAMES[stringidx])
    while True:
        #TODO: move string selection to fret:bit
        if button_a.was_pressed():
            stringidx = (stringidx + 1) % len(OPENSTRINGS)
            rootidx = OPENSTRINGS[stringidx]
            display.show(STRINGNAMES[stringidx])

        if button_b.was_pressed():
            chords = not chords
            if chords:
                display.show('C')
            else:
                display.show("S")

        tm = rdfret()
        if tm is None: tm = ptm
        am = scan()

        if not chords and tm != ptm:
            if tm == 0:
                display.show('0')
            else:
                pad = 1 + lowest_bit(tm)
                display.show(str(pad))

        if (am & LOW) != 0:
            octaveidx = 0
        elif (am & MID) != 0:
            octaveidx = 1
        elif (am & HIGH) != 0:
            octaveidx = 2

        if am != pam or tm != ptm:
            send(tm, am, chords)
            pam = am
            ptm = tm

try:
    init()
    del init
    display.show(Image.HAPPY)
    sleep(250)
    uart.init(baudrate=115200, rx=pin0)
    play()
except Exception as e:
    display.show(Image.NO)
    sleep(1000)
finally:
    reset()
